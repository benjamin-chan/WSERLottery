---
title: "2015 Western States Endurance Run Lottery"
author: "Benjamin Chan (https://github.com/benjamin-chan/WSERLottery)"
output:
  ioslides_presentation: default
---


```{r, echo=FALSE, results="hide"}
# PARAMETERS TO UPDATE
# ---------------------
# 26 folks with 32 tickets, each has a 78.1% chance of getting drawn
# 58 folks with 16 tickets, each has a 53.1% chance of getting drawn
# 143 folks with 8 tickets, each has a 31.5% chance of getting drawn
# 285 folks with 4 tickets, each has a 17.3% chance of getting drawn
# 658 folks with 2 tickets, each has a 9.0% chance of getting drawn
# 1409 folks with 1 ticket, each has a 4.6% chance of getting drawn
distn <- c(1409, 658, 285, 143, 58, 26)  # Number of entrants for each ticket count
probWSER <- c(4.6, 9.0, 17.3, 31.5, 53.1, 78.1)  # Selection probabilities from WSER
spots <- 270  # Number of spots up for grabs
size <- 1E5  # Use 1E6 for production, 1E3 for testing
dateLottery <- as.Date("2014-12-06", format="%Y-%m-%d")  # Random number seed; use lottery date
```


```{r, echo=FALSE, results="hide"}
# Simulation
# ----------
# Here, I run a simulation of the lottery process to estimate probabilities of
# winning a slot for the Western States Endurance Run. The simulation does a few
# things
# 
# * Use the `sample` function in R to sample without replacement using the
#   number of tickets each entrant has divided by the total number of tickets in
#   the *hat* as each entrant's selection probability for a single draw
# * Select draws from the *hat* equal to the number of spots available
# * Repeat each *lottery* a number of times
# * Use the `aggregate` function to summarize the simulations and derive an
#   emperical distribution of selection probabilities
# * Plot the selection probability distributions
#
# Set up initial conditions
#--------------------------
# Here is the code to set up the lottery hat data frame at the initial state.
# Print out some validation output just to make sure the initial state is set up
# correctly.
applicants <- sum(distn)
runner <- seq(1, applicants)
confail <- c(rep(5, distn[6]),
             rep(4, distn[5]),
             rep(3, distn[4]),
             rep(2, distn[3]),
             rep(1, distn[2]),
             rep(0, distn[1]))
tickets <- 2^confail
frameHat <- data.frame(runner, confail, tickets)
frameHat$prob <- frameHat$tickets / sum(frameHat$tickets)
addmargins(table(factor(frameHat$tickets)))  # Check for match with `distn` vector
aggregate(prob ~ tickets, frameHat, mean)  # Check success probabilities of an individual draw
# 
# Simulate lottery
# ----------------
# The simulation needs to account for the changing relative distribution of
# tickets after a person is selected and their tickets are no longer in the pool
# of eligible tickets.
# 
# The matrix `lottery` is an $I \times J$ matrix where row $i$ is the $i$-th
# simulation and the column $j$ is the $j$-th lottery winner drawn. The number
# of columns in the matrix is `r spots`, variable `spots`. The number of
# simulated lotteries is variable `size`. Set the random number seed as the date
# of the lottery in numeric form multipied by the number of applicants.
set.seed(as.numeric(dateLottery) * applicants)
require(parallel)
require(doParallel)
cores <- min(detectCores(), 4)
cl <- makeCluster(cores)
registerDoParallel(cl)
simTime <- system.time(
  lottery <- foreach (i=1:size, .combine=rbind) %dopar% {
    sample(frameHat$runner, spots, prob=frameHat$prob)
  }
)
stopCluster(cl)
#
# One simulated lottery
# ---------------------
i <- sample(seq(1, size), 1)
sampLottery <- list(i, sort(lottery[i, ]))
names(sampLottery) <- c("lottery", "runner")
sampLottery
# 
# Here's the distribution of the category of ticket holders from that random
# simulated lottery.
addmargins(table(frameHat$confail[sampLottery$runner]))
# 
# I.e., in simulated lottery `r i`, 
# * `r sum(frameHat$tickets[sampLottery$runner] == 1)` applicants with 1 ticket were selected  (`r format(100 * sum(frameHat$tickets[sampLottery$runner] == 1) / distn[1], digits=2)`%)
# * `r sum(frameHat$tickets[sampLottery$runner] == 2)` applicants with 2 tickets were selected (`r format(100 * sum(frameHat$tickets[sampLottery$runner] == 2) / distn[2], digits=2)`%)
# * `r sum(frameHat$tickets[sampLottery$runner] == 3)` applicants with 3 tickets were selected (`r format(100 * sum(frameHat$tickets[sampLottery$runner] == 3) / distn[3], digits=2)`%)
# * `r sum(frameHat$tickets[sampLottery$runner] == 4)` applicants with 4 tickets were selected (`r format(100 * sum(frameHat$tickets[sampLottery$runner] == 4) / distn[4], digits=2)`%)
# * `r sum(frameHat$tickets[sampLottery$runner] == 5)` applicants with 5 tickets were selected (`r format(100 * sum(frameHat$tickets[sampLottery$runner] == 5) / distn[5], digits=2)`%)
# 
# Okay... but what happened with the other `r size - 1` simulated lotteries?
# 
# Format lottery simulation data
# ------------------------------
# I'm not really interested in which runners were selected in the lottery
# simulation. What I'm really after are estimates for the probability of
# selecting a runner, among the `r spots` available spots, with $X$ tickets in
# the initial hat.
# 
# To get at this, first I'll have to match the runners selected to the number of
# tickets they started out with.
# lottery2 <- matrix(nrow=size, ncol=spots)
# for (i in 1:size) {
#   lottery2[i, ] <- frameHat$tickets[lottery[i, ]]
# }
cl <- makeCluster(cores)
registerDoParallel(cl)
lottery2 <- foreach (i=1:size, .combine=rbind) %dopar% {
  frameHat$confail[lottery[i, ]]
}
stopCluster(cl)
#
# Format lottery simulation data
# ------------------------------
# Reformat the `lottery2` matrix to an aggregated data frame for analysis.
confail <- factor(as.vector(t(lottery2)))
sim <- rep(seq(1, size), each=spots)
frameLottery <- data.frame(sim, confail)
require(data.table)
frameLottery <- data.table(frameLottery)
aggTime <- system.time(
  aggLottery <- frameLottery[,
                             list(confail.0 = sum(confail == 0),
                                  confail.1 = sum(confail == 1),
                                  confail.2 = sum(confail == 2),
                                  confail.3 = sum(confail == 3),
                                  confail.4 = sum(confail == 4),
                                  confail.5 = sum(confail == 5)),
                             sim]
)
nlev <- nlevels(frameLottery$confail)
sim <- rep(seq(1, size), each=nlev)
confail <- factor(rep(seq(1, nlev), size))
freq <- as.vector(t(aggLottery[, list(confail.0, confail.1, confail.2, confail.3, confail.4, confail.5)]))
frameSummary <- data.frame(sim, confail, freq)
require(reshape2)
frameSummary <- melt(aggLottery, id.vars=c("sim"))
frameSummary$confail <- factor(gsub("confail\\.", "", frameSummary$variable))
frameSummary$freq <- frameSummary$value
frameSummary[, c("variable", "value")] <- NULL
frameSummary <- frameSummary[order(frameSummary$sim, frameSummary$confail)]
# 
# Format lottery simulation data
# ------------------------------
# Save the aggregated data frame for other analysis.
save(aggLottery, file="aggLottery.RData")
# 
# Format lottery simulation data
# ------------------------------
# For each type of lottery applicant (1 ticket, 2 tickets, etc.), calculate the
# proportion of selected applicants.
total <- rep(distn, size)
frameSummary$prob <- 100 * (frameSummary$freq / total)
aggFx <- function(x) {c(mean = mean(x), median = median(x), sd = sd(x))}
aggProb <- aggregate(prob ~ confail, frameSummary, aggFx)
ev <- distn * aggProb[, "prob"][, "mean"] / 100
evWSER <- distn * probWSER / 100
diffprob <- aggProb[, "prob"][, "mean"] - probWSER
diffev <- ev - evWSER
pctdiff <- 100 * diffprob / aggProb[, "prob"][, "mean"]
sqerr <- diffprob ^2
simsum <- data.frame(confail = aggProb[, "confail"], distn, mean = aggProb[, "prob"][, "mean"], ev, probWSER, evWSER, diffprob, diffev, pctdiff, sqerr)
names(simsum) <- c("Consec. Failures", "N", "Mean", "EV", "Prob (WSER)", "EV (WSER)", "Diff. prob.", "Diff. EV", "% diff.", "Sq. error")
#
# Summarize lottery simulations
# -----------------------------
# Plot the distribution of probabilities from the `r format(size, big.mark=",")`
# simulated lotteries.
```


## Probability of selection

```{r PlotProbabilities, echo=FALSE}
title <- sprintf("%.0d WSER Lottery Selection Probability Densities", as.numeric(format(dateLottery, "%Y")) + 1)
xlab <- "Probability of selection"
ylab <- paste("Proportion of", format(size, big.mark=",", digits=0), "simulations")
filllab <- "Consecutive failures"
annolab <- sprintf("%.2f%%", simsum$Mean)
y0 <- max(density(frameSummary$prob[frameSummary$confail == 0])$y)
y1 <- max(density(frameSummary$prob[frameSummary$confail == 1])$y)
y2 <- max(density(frameSummary$prob[frameSummary$confail == 2])$y)
y3 <- max(density(frameSummary$prob[frameSummary$confail == 3])$y)
y4 <- max(density(frameSummary$prob[frameSummary$confail == 4])$y)
y5 <- max(density(frameSummary$prob[frameSummary$confail == 5])$y)
y <- c(y0, y1, y2, y3, y4, y5)
require(ggplot2, quietly=TRUE)
ggplot(frameSummary, aes(x=prob, y=..density.., fill=confail)) +
  geom_density(alpha=1/2, color=NA) +
  scale_fill_brewer(palette="Spectral") +
  labs(title=title, x=xlab, y=ylab, fill=filllab) +
  annotate("text", label=annolab, x=simsum$Mean, y=y) +
  theme(legend.position="bottom")
```

```{r, echo=FALSE, results="hide"}
# As expected, the spread of the selection probabilities increases as the number
# of tickets a person has in the hat increases (the variance of a binomial
# random variable increases with $p$).
# 
# Summarize lottery simulations
# -----------------------------
# Another way to think about the lottery is to plot the distribution of the
# frequency of runners selected by number of tickets.
```


## Number of entrants

```{r PlotFrequencies, echo=FALSE}
title <- sprintf("%.0d WSER Lottery Selection Distribution Densities", as.numeric(format(dateLottery, "%Y")) + 1)
xlab <- "Number of entrants selected"
ylab <- paste("Proportion of", format(size, big.mark=",", digits=0), "simulations")
filllab <- "Consecutive failures"
annolab <- sprintf("%.1f", simsum$EV)
y0 <- max(density(frameSummary$freq[frameSummary$confail == 0])$y)
y1 <- max(density(frameSummary$freq[frameSummary$confail == 1])$y)
y2 <- max(density(frameSummary$freq[frameSummary$confail == 2])$y)
y3 <- max(density(frameSummary$freq[frameSummary$confail == 3])$y)
y4 <- max(density(frameSummary$freq[frameSummary$confail == 4])$y)
y5 <- max(density(frameSummary$freq[frameSummary$confail == 5])$y)
y <- c(y0, y1, y2, y3, y4, y5)
ggplot(frameSummary, aes(x=freq, y=..density.., fill=confail)) +
  geom_density(alpha=1/2, color=NA) +
  scale_fill_brewer(palette="Spectral") +
  labs(title=title, x=xlab, y=ylab, fill=filllab) +
  annotate("text", label=annolab, x=simsum$EV, y=y) +
  theme(legend.position="bottom")
```

```{r, echo=FALSE, results="hide"}
# Summarize lottery simulations
# -----------------------------
# Compare to probabilities given in the WSER 2014 [lottery
# statistics](http://www.wser.org/2013/11/27/2014-lottery-statistics/).
require(xtable, quietly=TRUE)
print(xtable(simsum), type="html", include.rownames=FALSE)
#
# My estimates are *virtually identical* to the probabilities calculated by
# [WSER](http://www.wser.org/2013/11/27/2014-lottery-statistics) (*Mean* column
# versus the *Prob (WSER)* column). Percent differences of the selection
# probabilities are never more than `r max(abs(simsum$"% diff."))`% and the mean
# squared error of the selection probabilities is `r sprintf("%.6f",
# mean(simsum$"Sq. error"))`.
# 
# Outcome of sample of lotteries
# ------------------------------
```


## Sample of simulated lotteries

```{r, echo=FALSE, results="asis"}
s <- 25
title <- sprintf("Simulated %.0d WSER Lotteries\nSample of %.0f Lotteries", as.numeric(format(dateLottery, "%Y")) + 1, s)
xlab <- "Simulated lottery"
ylab <- "Number of selected runners\nEach block represents 10 runners"
filllab <- "Consecutive failures"
i <- sample(seq(1, size), s)
frameSample <- frameLottery[frameLottery$sim %in% i, ]
frameSample$sim <- factor(frameSample$sim)
levels(frameSample$sim) <- rev(levels(frameSample$sim))
ggplot(frameSample, aes(x=sim, fill=confail)) +
  geom_bar(width=1) +
  geom_hline(y=seq(0, spots, 10), color="white") +
  geom_vline(x=seq(1, s)-0.5, color="white") +
  scale_fill_brewer(palette="Spectral") +
  scale_y_continuous(expand=c(0, 0)) +
  labs(title=title, x=xlab, y=ylab, fill=filllab) +
  coord_flip() +
  theme(legend.position="top")
```

```{r, eval=FALSE, echo=FALSE, results="hide"}
# 
# Actual results
# --------------
# The actual lottery was held on December 7, 2012. Here are the results, from
# the Western States Endurance Run [Facebook post](https://www.facebook.com/perm
# alink.php?story_fbid=10152053026305412&id=293403870411),
# 
# > Congratulations to all those chosen in the lottery today. Here are some
# > stats for the ticket groups of the 270 selected (and predicted by our MC
# > simulations)
# > one ticket - 101 selected (112 predicted))  
# > two tickets - 78 (70)  
# > three tickets - 45 (47)  
# > four tickets -27 (25)  
# > five tickets - 19 (15)  
# 
# Actual results
# --------------
# Compare the observed lottery to the expected lottery.
yObs <- c(101, 78, 45, 27, 19)
yExp <- simsum$EV
frameObsExp <- data.frame(yObs, yExp, diff=yObs - yExp)
names(frameObsExp) <- c("Observed", "Expected", "Difference")
print(xtable(frameObsExp), type="html", include.rownames=FALSE)
# 
# Actual results
# --------------
# I wonder how many times this outcome appeared in my simulated lotteries?
y1 <- aggLottery$confail[,1] == yObs[1]
y2 <- aggLottery$confail[,2] == yObs[2]
y3 <- aggLottery$confail[,3] == yObs[3]
y4 <- aggLottery$confail[,4] == yObs[4]
y5 <- aggLottery$confail[,5] == yObs[5]
y <- y1 & y2 & y3 & y4 & y5
aggLottery[y,]
# 
# Of the `r format(size, big.mark=",")` simulated lotteries, only `r sum(y)`, or
# `r sprintf("%.5f%%", 100 * sum(y) / size)`, matched the exact outcome of the
# actual lottery.
```


## Details

Go to my [WSERLottery](https://github.com/benjamin-chan/WSERLottery) repository for the gory details.


## Session info

```{r, echo=FALSE}
message(sprintf("Timestamp: %s", Sys.time()))
message(sprintf("Number of cores used in simulation: %.0d", cores))
message(sprintf("Random number seed: %.0d", as.numeric(dateLottery) * applicants))
message(sprintf("Elapsed time of simulation: %.3f minutes", simTime[3] / 60))
message(sprintf("Elapsed time of aggregation: %.3f minutes", aggTime[3] / 60))
```

## Session info {.smaller}

```{r, echo=FALSE}
print(sessionInfo(), locale=FALSE)
```

## System info {.smaller}

```{r, echo=FALSE}
Sys.info()
```